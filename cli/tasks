#!winpty /c/Python39/python

from pyfiglet import Figlet
from PyInquirer import style_from_dict, Token, prompt, Separator
from pprint import pprint
import os 
import sys

# This is so Django knows where to find stuff.
# This is so my local_settings.py gets loaded.
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "recurringTasks.settings")
# putting everything in django context
import django
django.setup()

from task_management.apis.base import TaskManagementAPI
from task_management.utils import TaskTerm, TaskStatus, TaskPeriodTypes
tm_api = TaskManagementAPI()

# Logo
f = Figlet(font='big')
print (f.renderText('Recurring Tasks'))

# Styles
style = style_from_dict({
    Token.Separator: '#cc5454',
    Token.QuestionMark: '#673ab7 bold',
    Token.Selected: '#cc5454',  # default
    Token.Pointer: '#673ab7 bold',
    Token.Instruction: '',  # default
    Token.Answer: '#f44336 bold',
    Token.Question: '',
})

# CONFIG 
TODAYS_TASKS  = "Get today's tasks"
CREATE_TASK = "Create task"
VIEW_LIVE_TASKS = "View live tasks"
VIEW_DONE_TASKS = "View done tasks"
DELETE_TASK = "Delete task"
EXIT = 'Exit'

MAIN_OPTIONS = [
    TODAYS_TASKS,
    CREATE_TASK,
    VIEW_LIVE_TASKS,
    VIEW_DONE_TASKS,
    EXIT,
]

SINGLE_LINE_TASK_HEADERS = [
    "title",
    "due_date",
    "status",
]


def _format_task_line(task, headers):
    return '   '.join([str(task[header]) for header in headers ])


def _format_task_obj(task):
    '''
    Task editable by line
    '''
    headers = [
        "title",
        "due_date",
        "note",
        "term",
        "period",
        "status",
    ]


def get_todays_tasks():
    tasks = tm_api.get_tasks_for_today()
    headers = SINGLE_LINE_TASK_HEADERS

    formatted_tasks = [_format_task_line(task, headers) for task in tasks] + [EXIT]
    question = {
            'type': 'rawlist',
            'message': "LIVE TASKS:" + '   '.join(headers),
            'name': 'selection',
            'choices': formatted_tasks,
        }

    answer = prompt(question, style=style)
    if answer['selection'] != EXIT:
        index = formatted_tasks.index(answer['selection'])
        update_task(tasks[index])


def create_task():
    NONE = 'None'
    field_options = [
        ("title","Title", None),
        ("due_date","Due Date (YYYY-MM-DD)", None), # TODO: provide alt option for date format
        ("note","Note (OPTIONAL)", None),
        ("term","Term (OPTIONAL)", [NONE] + list(TaskTerm.labels)),
        ("period","Period (OPTIONAL)", [NONE] + list(TaskPeriodTypes.labels)),
        ("status","Status", list(TaskStatus.labels)),
    ]

    questions = []
    for field, message, options in field_options:
        if options:
            question = {
                'type': 'list',
                'name': field,
                'message': f'Select one of the following for {message}:',
                'choices': options,
            }
        else:
            question = {
                'type': 'input',
                'name': field,
                'message': f'Set {message}:',
            }
        questions.append(question)

    answers = prompt(questions, style=style)

    task_obj = {field:answers[field] for field, _, _ in field_options if answers[field] != NONE}
    tm_api.create_task(**task_obj)

def view_live_tasks():
    tasks = tm_api.get_live_tasks()
    headers = SINGLE_LINE_TASK_HEADERS

    formatted_tasks = [_format_task_line(task, headers) for task in tasks] + [EXIT]
    question = {
            'type': 'rawlist',
            'message': "LIVE TASKS:" + '   '.join(headers),
            'name': 'selection',
            'choices': formatted_tasks,
        }

    answer = prompt(question, style=style)
    if answer['selection'] != EXIT:
        index = formatted_tasks.index(answer['selection'])
        update_task(tasks[index])

def update_task(task_obj):
    field_options = {
        "title": None,
        "due_date": None,
        "note": None,
        "term": TaskTerm.labels,
        "period": TaskPeriodTypes.labels,
        "status": TaskStatus.labels,
        DELETE_TASK: None,
        EXIT: None,
    }

    question = {
        'type': 'list',
        'name': 'selection',
        'message': 'Select a parameter to update',
        'choices': formatted_options.keys()
    }

    # TODO: Add validation for each field_option
    answer = prompt(question, style=style)['selection']

    if field == DELETE_TASK:
        delete_task(task_obj['id'])
    else:
        if field != EXIT:
            if field_options.get(field):
                data = select_from_following(field_options.get(field))
            else:
                data = get_new_value(task_obj[field])
            task_obj[field] = data
            update_task(task_obj)

        tm_api.update_task(task_obj['id'], **task_obj)

def get_new_value(old_value):
    question = {
        'type': 'input',
        'name': 'user_input',
        'message': f'Overwrite current value {old_value}:',
    }
    return prompt(question, style=style)['user_input']

def select_from_following(options):
    question = {
        'type': 'list',
        'name': 'selection',
        'message': 'Select one of the following:',
        'choices': options + [EXIT],
    }

    answer = prompt(question, style=style)['selection']
    if answer != EXIT:
        return answer
    return None

def delete_task(task_id):
    if get_confirmation():
        tm_api.delete_task(task_id)

def get_confirmation():
    question = {
        'type': 'confirm',
        'message': "Are you sure?",
        'name': 'response',
    }

    return prompt(question, style=style)['response']


def view_done_tasks():
    tasks = tm_api.get_done_tasks()
    headers = SINGLE_LINE_TASK_HEADERS

    formatted_tasks = [_format_task_line(task, headers) for task in tasks] + [EXIT]
    question = {
            'type': 'rawlist',
            'message': "LIVE TASKS:" + '   '.join(headers),
            'name': 'selection',
            'choices': formatted_tasks,
        }

    answer = prompt(question, style=style)
    if answer['selection'] != EXIT:
        index = formatted_tasks.index(answer['selection'])
        update_task(tasks[index])



def handle_menu_answer(answer):
    handle_functions = {
        TODAYS_TASKS: get_todays_tasks,
        CREATE_TASK: create_task,
        VIEW_LIVE_TASKS: view_live_tasks,
        VIEW_DONE_TASKS: view_done_tasks,
    }

    handle_functions[answer]()

def main_menu():
    question = {
            'type': 'list',
            'message': 'Select:',
            'name': 'menu_selection',
            'choices': MAIN_OPTIONS,
        }

    answer = prompt(question, style=style)

    if answer['menu_selection'] != EXIT:
        handle_menu_answer(answer['menu_selection'])
        main_menu()


if __name__ == "__main__":
    main_menu()