#!winpty /c/Python39/python

from pyfiglet import Figlet
from PyInquirer import style_from_dict, Token, prompt, Separator
from pprint import pprint
import os 
import sys

# This is so my local_settings.py gets loaded.
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "recurringTasks.settings")

# putting everything in django context
import django
django.setup()

from task_management.apis.base import TaskManagementAPI
from task_management.utils import TaskTerm, TaskStatus, TaskPeriodTypes
tm_api = TaskManagementAPI()

# Logo
f = Figlet(font='big')
print (f.renderText('Recurring Tasks'))

# Styles
style = style_from_dict({
    Token.Separator: '#cc5454',
    Token.QuestionMark: '#673ab7 bold',
    Token.Selected: '#cc5454',  # default
    Token.Pointer: '#673ab7 bold',
    Token.Instruction: '',  # default
    Token.Answer: '#f44336 bold',
    Token.Question: '',
})

# CONFIG 
TODAYS_TASKS  = "Get Today's Tasks"
CREATE_TASK = "Create Task"
VIEW_LIVE_TASKS = "View Live Tasks"
VIEW_DONE_TASKS = "View Done Tasks"
DELETE_TASK = "Delete Task"
EXIT = 'Exit'

MAIN_OPTIONS = [
    TODAYS_TASKS,
    CREATE_TASK,
    VIEW_LIVE_TASKS,
    VIEW_DONE_TASKS,
    Separator(),
    EXIT,
]

SINGLE_LINE_TASK_HEADERS = [
    "title",
    "due_date",
    "status",
]

# HELPERS
def _format_string_with_value(string, value):
    new_string = " ".join([_string.capitalize() for _string in string.split('_')])
    return f"{new_string}: {value}"

def _format_task_line(task, headers):
    return '   '.join([str(task[header]) for header in headers ])

def _get_confirmation():
    question = {
        'type': 'confirm',
        'message': "Are you sure?",
        'name': 'response',
    }

    return prompt(question, style=style)['response']

def _get_new_value(old_value):
    question = {
        'type': 'input',
        'name': 'user_input',
        'message': f'Overwrite current value {old_value}:',
    }
    return prompt(question, style=style)['user_input']

def _select_from_following(options):
    question = {
        'type': 'list',
        'name': 'selection',
        'message': 'Select one of the following:',
        'choices': options + [EXIT],
    }

    answer = prompt(question, style=style)['selection']
    if answer != EXIT:
        return answer
    return None

# MAIL CLI FUNCTIONS
def view_tasks(tasks):
    formatted_tasks = [_format_task_line(task, SINGLE_LINE_TASK_HEADERS) for task in tasks] + [EXIT]
    question = {
            'type': 'rawlist',
            'message': "TASKS:",
            'name': 'selection',
            'choices': formatted_tasks,
        }

    answer = prompt(question, style=style)
    if answer['selection'] != EXIT:
        index = formatted_tasks.index(answer['selection'])
        update_task(tasks[index])

def get_todays_tasks():
    view_tasks(tm_api.get_tasks_for_today())

def view_live_tasks():
    view_tasks(tm_api.get_live_tasks())

def view_done_tasks():
    view_tasks(tm_api.get_done_tasks())

def create_task():
    NONE = 'None'
    field_options = [
        ("title","Title", None),
        ("due_date","Due Date", None),
        ("note","Note (OPTIONAL)", None),
        ("term","Term (OPTIONAL)", [NONE] + list(TaskTerm.labels)),
        ("period","Period (OPTIONAL)", [NONE] + list(TaskPeriodTypes.labels)),
        ("status","Status", list(TaskStatus.labels)),
    ]

    questions = []
    for field, message, options in field_options:
        if options:
            question = {
                'type': 'list',
                'name': field,
                'message': f'Select one of the following for {message}:',
                'choices': options,
            }
        else:
            question = {
                'type': 'input',
                'name': field,
                'message': f'Set {message}:',
            }
        questions.append(question)

    answers = prompt(questions, style=style)

    task_obj = {field:answers[field] for field, _, _ in field_options if answers[field] != NONE}
    tm_api.create_task(**task_obj)


def update_task(task_obj):
    field_options = {
        "title": None,
        "due_date": None,
        "note": None,
        "term": TaskTerm.labels,
        "period": TaskPeriodTypes.labels,
        "status": TaskStatus.labels,
    }

    choices = []

    for field, value in field_options.items():
        choice = {
            "name": _format_string_with_value(field, task_obj[field]), 
            "value": {
                "field": field,
                "value": value,
            },
        }
        choices.append(choice)

    question = {
        'type': 'list',
        'name': 'selection',
        'message': 'Select a parameter to update',
        'choices': choices + [DELETE_TASK, EXIT]
    }

    # TODO: Add validation for each field_option
    answer = prompt(question, style=style)['selection']

    if answer == DELETE_TASK:
        delete_task(task_obj['id'])
    else:
        if answer != EXIT:
            field = answer['field']
            value = answer['value']
            if value:
                data = _select_from_following(value)
            else:
                data = _get_new_value(task_obj[field])
            task_obj[field] = data
            update_task(task_obj)

        tm_api.update_task(task_obj['id'], **task_obj)

def delete_task(task_id):
    if _get_confirmation():
        tm_api.delete_task(task_id)


def handle_menu_answer(answer):
    handle_functions = {
        TODAYS_TASKS: get_todays_tasks,
        CREATE_TASK: create_task,
        VIEW_LIVE_TASKS: view_live_tasks,
        VIEW_DONE_TASKS: view_done_tasks,
    }

    handle_functions[answer]()

def main_menu():
    question = {
            'type': 'list',
            'message': 'Select:',
            'name': 'menu_selection',
            'choices': MAIN_OPTIONS,
        }

    answer = prompt(question, style=style)

    if answer['menu_selection'] != EXIT:
        handle_menu_answer(answer['menu_selection'])
        main_menu()


if __name__ == "__main__":
    main_menu()